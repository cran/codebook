---
title: "Codebook example with manual labelling"
author: "Ruben Arslan"
date: "`r Sys.Date()`"
output:
  html_vignette:
    fig_width: 7
    fig_height: 6
vignette: >
  %\VignetteIndexEntry{Example with manual labelling}
  \%VignetteKeyword{manual}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


In this vignette, you can see how to add metadata to a dataset when it isn't already 
stored in its attributes. For this example, we'll use the `bfi` and `bfi.dictionary`
datasets from the `psych` package. We use functions from the `labelled` package
to set the relevant attributes with convenience functions.


```{r message = FALSE}
knit_by_pkgdown <- !is.null(knitr::opts_chunk$get("fig.retina"))
library(dplyr)
library(codebook)
library(labelled)
pander::panderOptions("table.split.table", Inf)
ggplot2::theme_set(ggplot2::theme_bw())

data("bfi", package = 'psych')
bfi <- bfi %>% tbl_df()
data("bfi.dictionary", package = 'psych')
bfi.dictionary <- tibble::rownames_to_column(bfi.dictionary, "variable") %>% 
  tbl_df()
```

Let's start by getting an overview of our dataset
```{r}
head(bfi, 20)
```

and our data dictionary.
```{r}
bfi.dictionary
```

## How to add variable and value labels
Using the `var_label` function from the `labelled` package, we can easily assign
a label to a variable (or a list of labels to a dataset).

```{r}
# First, let's see what we know about these variables.
bfi <- bfi %>% # here we use the pipe (feeding the bfi argument into the pipe)
  mutate(education = as.double(education), # the labelled class is a bit picky and doesn't like integers
         gender = as.double(gender))

bfi.dictionary %>% tail(3)
var_label(bfi$gender) <- "Self-reported gender"
attributes(bfi$gender) # check what we're doing
var_label(bfi) <- list(age = "age in years", education = "Highest degree")

# or using dplyr syntax
bfi <- bfi %>% set_variable_labels(
  age = "age in years", 
  education = "Highest degree")
```

Now, we saw that the value labels were encoded in the variable label. This is not
what we want. Instead, we assign value labels.
```{r}
bfi <- bfi %>% 
  add_value_labels(
    gender = c("male" = 1, "female" = 2),
    education = c("in high school" = 1, "finished high school" = 2,
                  "some college" = 3, "college graduate" = 4, 
                  "graduate degree" = 5) # dont use abbreviations if you can avoid it
    )
attributes(bfi$gender) # check what we're doing

# We could also assign the attributes manually, but then there's no error checking.
attributes(bfi$gender) <- list(
  label = "Self-reported gender", 
  labels = c(male = 1L, female = 2L), 
  class = "haven_labelled")
```

As we see, adding value labels turned the variable `gender` into a different type (from
a simple integer to a labelled class).

This is all pretty tedious, and we have the data we need in a nice dictionary 
already. With a few easy steps, we can transform it.

First, we take only the personality items. We did the rest already.
```{r}
dict <- bfi.dictionary %>% 
  filter(!variable %in% c("gender", "education", "age")) %>% # we did those already
  mutate(label = paste0(Big6, ": ", Item)) %>% # make sure we name the construct in the label
  select(variable, label, Keying)
```

Now, we turn this data.frame with variable and label columns into a named list and assign it as variable labels.
```{r}
var_label(bfi) <- dict_to_list(dict)
```


Now, we want to assign value labels to all likert items. First, we need to define
a named vector.
```{r}
value_labels <- c("Very Inaccurate" = 1, 
                  "Moderately Inaccurate" = 2, 
                  "Slightly Inaccurate" = 3,
                  "Slightly Accurate" = 4,
                  "Moderately Accurate" = 5,
                  "Very Accurate" = 6)
```

We're going to be using these labels many times, so let's 
put the step of assigning them into a function.
```{r}
add_likert_label <- function(x) {
  val_labels(x) <- value_labels
  x
}
```


Now, for all personality items (we get them from our data dictionary),
we assign these value labels.

```{r}
personality_items <- dict %>% pull(variable)
bfi <- bfi %>% 
  mutate_at(personality_items, 
                         add_likert_label)
```


However, some of our items are reverse-coded. This information is contained
in the `Keying` variable in our data dictionary. We'll use it to rename the
variables to end with the letter R.

```{r}
# reverse underlying values for the reverse-keyed items
reverse_coded_items <- dict %>% filter(Keying == -1) %>% pull(variable)

bfi <- bfi %>% 
  rename_at(reverse_coded_items, add_R)
```

Next, we can conveniently call the `reverse_labelled_values` function
on all variables ending with a number and R.
```{r}
head(bfi$A1R, 3)
labelled::val_labels(bfi$A1R)
bfi <- bfi %>% 
  mutate_at(
    vars(matches("[0-9]_?R$")), # only for variables that end in 1R 2_R 3R etc
    reverse_labelled_values)
labelled::val_labels(bfi$A1R)
head(bfi$A1R, 3)
```

As you can see, the underlying numeric values have changed, but the labels
are still the way the participant answered them.

## Aggregating scales

Now, we can form scale aggregates. The `codebook` function `aggregate_and_document_scale` does this for us and automatically sets the correct attributes. For some `select` calls her,e we have to set `ignore.case` to FALSE,
or it would match the `age` and `education` variables.

```{r}
bfi$consc <- aggregate_and_document_scale(bfi %>% select(starts_with("C")))
bfi$extra <- aggregate_and_document_scale(bfi %>% select(starts_with("E", ignore.case = F)))
bfi$open <- aggregate_and_document_scale(bfi %>% select(starts_with("O")))
bfi$agree <- aggregate_and_document_scale(bfi %>% select(starts_with("A", ignore.case = F)))
bfi$neuro <- aggregate_and_document_scale(bfi %>% select(starts_with("N")))
```


Last, we can assign some metadata to the dataset itself. We might want
to give it a meaningful name and description, for example.

```{r}
metadata(bfi)$name <- "25 Personality items representing 5 factors"
metadata(bfi)$description <- "25 personality self report items taken from the International Personality Item Pool (ipip.ori.org) were included as part of the Synthetic Aperture Personality Assessment (SAPA) web based personality assessment project. The data from 2800 subjects are included here as a demonstration set for scale construction, factor analysis, and Item Response Theory analysis. Three additional demographic variables (sex, education, and age) are also included.

The first 25 items are organized by five putative factors: Agreeableness, Conscientiousness, Extraversion, Neuroticism, and Opennness. The item data were collected using a 6 point response scale: 1 Very Inaccurate 2 Moderately Inaccurate 3 Slightly Inaccurate 4 Slightly Accurate 5 Moderately Accurate 6 Very Accurate

To see an example of the data collection technique, visit https://SAPA-project.org or the International Cognitive Ability Resource at https://icar-project.com. The items given were sampled from the International Personality Item Pool of Lewis Goldberg using the sampling technique of SAPA. This is a sample data set taken from the much larger SAPA data bank."
metadata(bfi)$identifier <- "https://CRAN.R-project.org/package=psych"
metadata(bfi)$datePublished <- "2010-01-01"
metadata(bfi)$creator <- list(
      "@type" = "Person",
      givenName = "William", familyName = "Revelle",
      email = "revelle@northwestern.edu", 
      affiliation = list("@type" = "Organization",
        name = "Northwestern University"))
metadata(bfi)$citation <- "Revelle, W., Wilt, J., and Rosenthal, A. (2010) Individual Differences in Cognition: New Methods for examining the Personality-Cognition Link In Gruszka, A. and Matthews, G. and Szymura, B. (Eds.) Handbook of Individual Differences in Cognition: Attention, Memory and Executive Control, Springer."
metadata(bfi)$url <- "https://CRAN.R-project.org/package=psych"
metadata(bfi)$temporalCoverage <- "Spring 2010" 
metadata(bfi)$spatialCoverage <- "Online" 
```

```{r}
# We don't want to look at the code in the codebook.
knitr::opts_chunk$set(warning = TRUE, message = TRUE, echo = FALSE)
```

Finally, we can generate our codebook.

```{r cb}
codebook(bfi, survey_repetition = "single",
         metadata_table = knit_by_pkgdown, metadata_json = knit_by_pkgdown)
```


`r ifelse(knit_by_pkgdown, '', '### Codebook table')`

```{r}
if (!knit_by_pkgdown) {
  codebook:::escaped_table(codebook_table(bfi))
}
```

