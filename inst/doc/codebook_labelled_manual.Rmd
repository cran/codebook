---
title: "Codebook example with manual labelling"
author: "Ruben Arslan"
date: "`r Sys.Date()`"
output:
  html_vignette:
    fig_width: 7
    fig_height: 6
vignette: >
  %\VignetteIndexEntry{Example with manual labelling}
  \%VignetteKeyword{manual}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


In this vignette, you can see how to add metadata to a dataset when it isn't already 
stored in its attributes. For this example, we'll use the `bfi` and `bfi.dictionary`
datasets from the `psych` package. We use functions from the `labelled` package
to set the relevant attributes with convenience functions.


```{r message = FALSE}
knit_by_pkgdown <- !is.null(knitr::opts_chunk$get("fig.retina"))
library(dplyr)
library(codebook)
library(labelled)
pander::panderOptions("table.split.table", Inf)
ggplot2::theme_set(ggplot2::theme_bw())

data("bfi", package = 'psych')
bfi <- bfi %>% tbl_df()
data("bfi.dictionary", package = 'psych')
bfi.dictionary$variable = rownames(bfi.dictionary)
bfi.dictionary <- bfi.dictionary %>% tbl_df()
```

Let's start by getting an overview of our dataset
```{r}
head(bfi, 20)
```

and our data dictionary.
```{r}
bfi.dictionary
```

## How to add variable and value labels
Using the `var_label` function from the `labelled` package, we can easily assign
a label to a variable (or a list of labels to a dataset).

```{r}
# First, let's see what we know about these variables.
bfi <- bfi %>% # here we use the pipe (feeding the bfi argument into the pipe)
  mutate(education = as.double(education), # the labelled class is a bit picky and doesn't like integers
         gender = as.double(gender))

bfi.dictionary %>% tail(3)
var_label(bfi$gender) <- "Self-reported gender"
attributes(bfi$gender) # check what we're doing
var_label(bfi) <- list(age = "age in years", education = "Highest degree")

# or using dplyr syntax
bfi <- bfi %>% set_variable_labels(
  age = "age in years", 
  education = "Highest degree")
```

Now, we saw that the value labels were encoded in the variable label. This is not
what we want. Instead, we assign value labels.
```{r}
bfi <- bfi %>% 
  add_value_labels(
    gender = c("male" = 1, "female" = 2),
    education = c("in high school" = 1, "finished high school" = 2,
                  "some college" = 3, "college graduate" = 4, 
                  "graduate degree" = 5) # dont use abbreviations if you can avoid it
    )
attributes(bfi$gender) # check what we're doing

# We could also assign the attributes manually, but then there's no error checking.
attributes(bfi$gender) <- list(
  label = "Self-reported gender", 
  labels = c(male = 1L, female = 2L), 
  class = "labelled")
```

As we see, adding value labels turned the variable `gender` into a different type (from
a simple integer to a labelled class).

This is all pretty tedious, and we have the data we need in a nice dictionary 
already. With a few easy steps, we can transform it.

```{r}
dict <- bfi.dictionary %>% 
  filter(! variable %in% c("gender", "education", "age")) %>% # we did those already
  mutate(label = paste0(Big6, ": ", Item)) %>% # make sure we name the construct in the label
  select(variable, label, Keying)

# turn the key-value data frame into  a list
labels <- dict$label %>% as.character() %>% as.list() %>% 
  purrr::set_names(dict$variable)

# assign the list of labels to the bfi data frame
var_label(bfi) <- labels

# assign value labels to all likert items
value_labels <- c("Very Inaccurate" = 1, 
                  "Moderately Inaccurate" = 2, 
                  "Slightly Inaccurate" = 3,
                  "Slightly Accurate" = 4,
                  "Moderately Accurate" = 5,
                  "Very Accurate" = 6)

add_likert_label <- function(x) {
  val_labels(x) <- value_labels
  x
}

bfi <- bfi %>% 
  mutate_at(dict %>% pull(variable), 
                         add_likert_label)

# reverse underlying values for the reverse-keyed items
bfi <- bfi %>% 
  mutate_at(dict %>% filter(Keying == -1) %>% pull(variable), 
    reverse_labelled_values) %>% 
  rename_at(dict %>% filter(Keying == -1) %>% pull(variable), 
    ~ paste0(.,"R"))

attributes(bfi$A1R)
```

## Aggregating scales

Now, we can form scale aggregates. The `codebook` function `aggregate_and_document_scale`
does this for us and automatically sets the correct attributes.

```{r}
bfi$consc <- aggregate_and_document_scale(bfi %>% select(starts_with("C")))
bfi$extra <- aggregate_and_document_scale(bfi %>% select(starts_with("E", ignore.case = F)))
bfi$open <- aggregate_and_document_scale(bfi %>% select(starts_with("O")))
bfi$agree <- aggregate_and_document_scale(bfi %>% select(starts_with("A", ignore.case = F)))
bfi$neuro <- aggregate_and_document_scale(bfi %>% select(starts_with("N")))
```

```{r}
knitr::opts_chunk$set(warning = TRUE, message = TRUE, error = TRUE, echo = FALSE)
```


Finally, we can generate our codebook.

```{r cb}
codebook(bfi, survey_repetition = "single",
         metadata_table = knit_by_pkgdown, metadata_json = knit_by_pkgdown)
```


`r ifelse(knit_by_pkgdown, '', '### Codebook table')`

```{r}
if (!knit_by_pkgdown) {
  codebook:::escaped_table(codebook_table(bfi))
}
```

